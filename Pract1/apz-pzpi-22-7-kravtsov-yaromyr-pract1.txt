Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки 
Кафедра програмної інженерії 














Звіт з практичної роботи № 1
 з дисципліни «Архітектура програмного забезпечення»










Перевірив                                                            Виконав 
ст. викладач ПІ                                                          ст. групи ПЗПІ-22-7 
Сокорчук Ігор Петрович                                     Кравцов Я.П.






























Харків 2025


1 ІСТОРІЯ ЗМІН 




№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	28.03.2025
	0.1
	Створення роботи
	



2 ЗАВДАННЯ


1. Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ»
(із книг: Ґамма, “ООП. Патерни проєктування”, GoF, крім патерна Singletone)
2. Створити та оформити слайди презентації доповіді
3. Створити та опублікувати на YouTube відеозапис доповіді
4. Оформити та завантажити на dl.nure.ua звіт до виконаної роботи
5. При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua
6. Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main
7. Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань
8. Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub
9. Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1




3 ОПИС ВИКОНАНОЇ РОБОТИ


У даній роботі здійснено комплексний аналіз, розробку та практичну реалізацію патерну Facade у контексті сучасного проєктування програмного забезпечення. Робота спрямована на вивчення можливостей зниження складності інтеграції численних підсистем через використання спрощеного єдиного інтерфейсу, що забезпечує підвищення модульності, гнучкості та підтримуваності програмного коду. Нижче наведено детальний опис етапів виконаної роботи.


3.1 Теоретичний аналіз та узагальнення концепції патерну
На першому етапі було проведено детальний огляд літературних джерел та сучасних практик застосування структурних патернів у програмному забезпеченні. Було встановлено, що патерн Facade дозволяє:
   * Приховати внутрішню складність системи: Завдяки централізованому інтерфейсу, користувач або розробник отримує доступ лише до необхідних методів, не звертаючись до внутрішньої логіки окремих компонентів.
   * Знизити зв’язаність між підсистемами: Фасад виступає проміжною ланкою, що ізолює окремі модулі один від одного, що сприяє більшій гнучкості при внесенні змін.
   * Покращити читабельність та підтримку коду: Єдиний API дозволяє зосередитися на бізнес-логіці програми, а не на взаємодії між багатьма компонентами.
Аналіз показав, що Facade є надзвичайно корисним у великих проєктах, де без чітко структурованого підходу складність системи може значно зростати.


3.2 Розробка концептуальної архітектури
На основі теоретичного аналізу була розроблена концептуальна модель системи, де патерн Facade виконує роль центрального елементу інтеграції:
   * Створено архітектурну діаграму: Фасад розташований у центрі схеми, а від нього відгалужуються зв’язки до окремих підсистем (наприклад, SubsystemA, SubsystemB).

   * Визначено ключові компоненти системи:
      * Facade: Єдиний інтерфейс для взаємодії із системою, який інкапсулює виклики методів підсистем.
      * Підсистеми: Окремі модулі з власною логікою, що реалізують конкретні операції (наприклад, обчислення, обробку даних або управління ресурсами).

         * Модульність та масштабованість: Проаналізовано, як застосування фасаду дозволяє легко інтегрувати нові підсистеми, розширюючи функціональність без порушення існуючої архітектури.
Цей етап дозволив сформувати чітке бачення майбутньої реалізації з урахуванням принципів об’єктно-орієнтованого програмування та інкапсуляції.


3.4 Практична реалізація на базі TypeScript
У ході практичної реалізації було розроблено наступну структуру коду:
         * Реалізація підсистем:
         * SubsystemA: Розроблено клас, що містить метод operationA(), який повертає результат виконання певної логіки.
         * SubsystemB: Аналогічно, створено клас з методом operationB(), що відповідає за окрему частину функціональності.
         * Реалізація фасадного класу:
Ініціалізація підсистем: У конструкторі класу Facade створюються об’єкти підсистем, що гарантує їх готовність до роботи.
            * Об’єднання методів: Розроблено публічний метод operation(), який викликає відповідні методи кожної підсистеми та повертає їх об’єднаний результат. Цей підхід дозволяє користувачу отримувати необхідну інформацію через єдиний інтерфейс.
            * Документування та коментування: Код містить докладні коментарі, що пояснюють функціональність кожного блоку, що підвищує зрозумілість та сприяє подальшій підтримці.

Використання TypeScript дозволило забезпечити статичну типізацію, що є важливим аспектом для попередження помилок на етапі компіляції та сприяє створенню більш стабільного програмного забезпечення.


3.4 Оцінка ефективності та демонстрація роботи
Реалізоване рішення було перевірено за допомогою тестування, що включало:
               * Демонстраційний запуск коду: Було проведено запуск програмного коду, що підтвердило коректність роботи патерну Facade – метод operation() успішно викликав відповідні методи підсистем та повертав об’єднаний результат.
               * Аналіз зниження зв’язаності: Проведено порівняльний аналіз коду до та після впровадження фасаду. Було відзначено значне зниження рівня зв’язаності між компонентами, що підтверджує доцільність використання патерну для масштабних систем.
               * Оцінка модульності: Розроблене рішення демонструє високу модульність, оскільки можливе подальше розширення функціональності через додавання нових підсистем без зміни існуючого коду фасаду.


3.5 Науково-технічні аспекти та рекомендації
У ході виконання роботи були враховані наступні науково-технічні аспекти:
               * Принципи SOLID: Розробка здійснювалася з урахуванням принципів об’єктно-орієнтованого програмування, зокрема принципу єдиної відповідальності, що забезпечує легкість підтримки коду.
               * Інкапсуляція та абстракція: За рахунок використання фасаду досягнуто високого рівня інкапсуляції, що дозволяє приховати складну внутрішню логіку підсистем та надавати користувачу лише необхідний функціонал.
               * Масштабованість системи: Розроблене рішення сприяє легкому масштабуванню та інтеграції додаткових модулів, що є важливим для сучасних динамічних програмних рішень.
На основі отриманих результатів рекомендовано використовувати патерн Facade у проєктах з великою кількістю компонентів та високою складністю інтеграції, де критично важлива підтримка та масштабованість системи.




4 ВИСНОВКИ


Проведена робота підтвердила ефективність застосування патерну Facade для спрощення взаємодії між підсистемами. Розроблена архітектурна модель та практична реалізація на базі TypeScript демонструють, як за допомогою одного спрощеного інтерфейсу можна знизити зв’язаність компонентів, підвищити модульність та забезпечити стабільність програмного забезпечення. Отримані результати є вагомим доказом доцільності використання патерну Facade у сучасних інформаційних системах та можуть бути використані як основа для подальших досліджень і впровадження у масштабних проєктах.




ДОДАТОК A


Відеозапис доповіді на YouTube: https://youtu.be/XLEGszpaS2A


ДОДАТОК Б


  

Рисунок Б.1 – Змістовна назва першого слайда










  

Рисунок Б.2 – Визначення патерну Facade та його основна ідея


  

Рисунок Б.3 – Визначення патерну Facade та його основна ідея


  
Рисунок Б.4 – Ключові визначення: Facade, підсистема, інкапсуляція


  

Рисунок Б.5 – Діаграма з розташуванням Facade та взаємодіючих підсистем
  
Рисунок Б.6 – Статична типізація та об’єктно-орієнтований підхід для кращої підтримки коду


  

Рисунок Б.7 – Представлення класу SubsystemA з його функцією
  

Рисунок Б.8 – Представлення класу SubsystemB та його основної операції.


  

Рисунок Б.9 – Оголошення класу Facade та визначення властивостей підсистем


  
Рисунок Б.10 – Конструктор Facade: ініціалізація підсистем


  

Рисунок Б.11 – Реалізація методу operation(), що об’єднує виклики підсистем




  
Рисунок Б.12 – Приклад створення екземпляра Facade і виклику operation


  

Рисунок Б.13 – Коротке резюме переваг: спрощення, зниження зв’язаності, масштабованість
  
Рисунок Б.14 – Основні обмеження та ситуації, коли Facade може бути не доцільним


  

Рисунок Б.15 – Приклади застосування Facade у великих проєктах та інтеграція з іншими патернами
  

Рисунок Б.16 – Підсумок основних ідей




ДОДАТОК В


         1        // Підсистема A: відповідає за виконання операції A
         2        class SubsystemA {
         3            operationA(): string {
         4                return "Результат операції A";
         5            }
         6        }
           
         7        // Підсистема B: відповідає за виконання операції B
         8        class SubsystemB {
         9            operationB(): string {
        10                return "Результат операції B";
        11            }
        12        }
           
        13        // Фасад: об’єднує роботу підсистем і забезпечує єдиний інтерфейс
        14        class Facade {
        15            private subsystemA: SubsystemA;
        16            private subsystemB: SubsystemB;
           
        17            // Конструктор ініціалізує підсистеми
        18            constructor() {
        19                this.subsystemA = new SubsystemA();
        20                this.subsystemB = new SubsystemB();
        21            }
           
        22            // Метод operation() викликає методи підсистем і об’єднує їх результати
        23            public operation(): string {
        24                const resultA = this.subsystemA.operationA();
        25                const resultB = this.subsystemB.operationB();
        26                return `Facade об’єднує: [${resultA}] та [${resultB}]`;
        27            }
        28        }
           
        29        // Демонстрація використання фасаду
        30        const facade = new Facade();
        31        console.log(facade.operation());